# =================================================================================
# ARQUIVO DE CONFIGURAÇÃO LOGSTASH PARA LOGS MIKROTIK (v26 - Final)
# Adicionado padrão para lidar com logs de protocolos sem portas (ex: IGMP, ICMP).
# =================================================================================

#---------------------------------------------------------------------------------
# SEÇÃO DE ENTRADA (INPUT)
# Recebe os logs do MikroTik.
#---------------------------------------------------------------------------------
input {
  udp {
    port => 514
    codec => "line"
    type => "mikrotik_firewall"
  }
}

#---------------------------------------------------------------------------------
# SEÇÃO DE FILTROS (FILTER)
# Processa, analisa (parse), enriquece e transforma os logs brutos.
#---------------------------------------------------------------------------------
filter {
  # Adiciona uma cópia da mensagem original para fins de depuração.
  mutate {
    add_field => { "debug_message" => "%{message}" }
  }

  # 1. PARSING INICIAL COM GROK 
  # A lista é processada em ordem. O primeiro padrão que corresponder é usado.
  grok {
    match => {
      "message" => [
        # Padrão 1 (NOVO): Lida com logs de protocolos sem portas (ex: ICMP, IGMP).
        "firewall,info %{WORD:entry_type}:? in:%{NOTSPACE:in_interface} out:%{NOTSPACE:out_interface},? connection-state:%{NOTSPACE:connection_state}(?:,? src-mac %{MAC:src_mac})?,? proto %{DATA:protocol},? %{IP:src_ip}->%{IP:dst_ip},? len %{INT:length}",
        
        # Padrão 2: Lida com logs que têm um prefixo customizado E informação de NAT.
        "firewall,info \[%{GREEDYDATA:entry_type}\]: in:%{NOTSPACE:in_interface} out:%{NOTSPACE:out_interface},? connection-mark:%{NOTSPACE:connection_mark} connection-state:%{NOTSPACE:connection_state}(?:,? src-mac %{MAC:src_mac})?,? proto %{WORD:protocol},? %{IP:src_ip}:%{INT:src_port}->%{IP:dst_ip}:%{INT:dst_port},? NAT %{GREEDYDATA:nat_info} len %{INT:length}",
        
        # Padrão 3: Lida com logs que têm um prefixo customizado mas SEM informação de NAT.
        "firewall,info \[%{GREEDYDATA:entry_type}\]: in:%{NOTSPACE:in_interface} out:%{NOTSPACE:out_interface},? connection-mark:%{NOTSPACE:connection_mark} connection-state:%{NOTSPACE:connection_state}(?:,? src-mac %{MAC:src_mac})?,? proto %{WORD:protocol},? %{IP:src_ip}:%{INT:src_port}->%{IP:dst_ip}:%{INT:dst_port},? len %{INT:length}",

        # Padrão 4: Lida com logs padrão com 'connection-mark' e 'NAT'.
        "firewall,info %{WORD:entry_type}:? in:%{NOTSPACE:in_interface} out:%{NOTSPACE:out_interface},? connection-mark:%{NOTSPACE:connection_mark} connection-state:%{NOTSPACE:connection_state}(?:,? src-mac %{MAC:src_mac})?,? proto %{WORD:protocol},? %{IP:src_ip}:%{INT:src_port}->%{IP:dst_ip}:%{INT:dst_port},? NAT %{GREEDYDATA:nat_info} len %{INT:length}",
        
        # Padrão 5: Lida com logs padrão com 'connection-mark' mas SEM 'NAT'.
        "firewall,info %{WORD:entry_type}:? in:%{NOTSPACE:in_interface} out:%{NOTSPACE:out_interface},? connection-mark:%{NOTSPACE:connection_mark} connection-state:%{NOTSPACE:connection_state}(?:,? src-mac %{MAC:src_mac})?,? proto %{WORD:protocol},? %{IP:src_ip}:%{INT:src_port}->%{IP:dst_ip}:%{INT:dst_port},? len %{INT:length}",
        
        # Padrão 6: Lida com logs padrão SEM 'connection-mark'.
        "firewall,info %{WORD:entry_type}:? in:%{NOTSPACE:in_interface} out:%{NOTSPACE:out_interface},? connection-state:%{NOTSPACE:connection_state}(?:,? src-mac %{MAC:src_mac})?,? proto %{WORD:protocol},? %{IP:src_ip}:%{INT:src_port}->%{IP:dst_ip}:%{INT:dst_port},? len %{INT:length}",

        # Padrão extra flexível para logs com ou sem colchetes, com ou sem NAT, e out_interface variável
        "firewall,info(?: (?:\[%{GREEDYDATA:entry_type}\]|%{WORD:entry_type}))?(?: prerouting:)? in:%{NOTSPACE:in_interface} out:%{DATA:out_interface},? (?:packet-mark:%{NOTSPACE:packet_mark} )?(?:connection-mark:%{NOTSPACE:connection_mark} )?connection-state:%{NOTSPACE:connection_state},?snat src-mac %{MAC:src_mac}, proto %{WORD:protocol} \(%{DATA:tcp_flags}\), %{IP:src_ip}:%{INT:src_port}->%{IP:dst_ip}:%{INT:dst_port}, NAT %{IP:nat_src_ip}:%{INT:nat_src_port}->\(%{IP:nat_dst_ip}:%{INT:nat_dst_port}->%{IP:nat_final_ip}:%{INT:nat_final_port}\), len %{INT:length}",

        # Novo padrão: múltiplas palavras após 'firewall,info', sem NAT e sem connection-mark
        "firewall,info %{GREEDYDATA:entry_type}: in:%{NOTSPACE:in_interface} out:%{DATA:out_interface}, connection-state:%{NOTSPACE:connection_state} src-mac %{MAC:src_mac}, proto %{WORD:protocol}, %{IP:src_ip}:%{INT:src_port}->%{IP:dst_ip}:%{INT:dst_port}, len %{INT:length}",

        # Novo padrão: connection-state:new,dnat e NAT detalhado
        "firewall,info %{WORD:entry_type}: in:%{NOTSPACE:in_interface} out:%{DATA:out_interface}, connection-state:%{NOTSPACE:connection_state},dnat src-mac %{MAC:src_mac}, proto %{WORD:protocol} \(%{DATA:tcp_flags}\), %{IP:src_ip}:%{INT:src_port}->%{IP:dst_ip}:%{INT:dst_port}, NAT %{IP:nat_src_ip}:%{INT:nat_src_port}->\(%{IP:nat_dst_ip}:%{INT:nat_dst_port}->%{IP:nat_final_ip}:%{INT:nat_final_port}\), len %{INT:length}",

        # Novo padrão: dstnat ou prerouting sem NAT detalhado
        "firewall,info %{WORD:entry_type}: in:%{NOTSPACE:in_interface} out:%{DATA:out_interface}, connection-state:%{NOTSPACE:connection_state} src-mac %{MAC:src_mac}, proto %{WORD:protocol} \(%{DATA:tcp_flags}\), %{IP:src_ip}:%{INT:src_port}->%{IP:dst_ip}:%{INT:dst_port}, len %{INT:length}"
      ]
    }
    tag_on_failure => ["_grokparsefailure"]
  }

  # 2. PARSING CONDICIONAL PARA INFORMAÇÕES DE NAT
  if [nat_info] {
    grok {
      # Extrai o IP e a Porta de destino do NAT.
      match => { "nat_info" => "^\(%{GREEDYDATA}->%{IP:nat_dst_ip}:%{INT:nat_dst_port}\)" }
    }
  }

  # 3. LIMPEZA E NORMALIZAÇÃO
  if ![out_interface] or [out_interface] == "(unknown 0)" or [out_interface] == "(none)" {
    mutate {
      replace => { "out_interface" => "N/A" }
    }
  }
  
  mutate {
    gsub => [ "out_interface", ",$", "" ]
  }

  # 4. CONVERSÃO DE TIPOS DE DADOS
  mutate {
    convert => {
      "src_port" => "integer"
      "dst_port" => "integer"
      "length" => "integer"
      "nat_dst_port" => "integer"
    }
  }

  # 5. ENRIQUECIMENTO COM CONTEXTO TEMPORAL
  ruby {
    code => '
      begin
        timestamp = event.get("@timestamp")
        timestamp.time.localtime("-03:00")
        hour = timestamp.time.hour
        wday = timestamp.time.wday
        if wday >= 1 && wday <= 5 && hour >= 8 && hour < 18
          event.set("[time_context][period]", "horario_comercial")
        else
          event.set("[time_context][period]", "fora_de_hora")
        end
        days = ["Domingo", "Segunda-feira", "Terça-feira", "Quarta-feira", "Quinta-feira", "Sexta-feira", "Sábado"]
        event.set("[time_context][day_of_week]", days[wday])
        if timestamp.time.month == 6
          event.set("[time_context][event]", "Festas Juninas")
        end
      rescue => e
        event.set("[ruby_error_time_context]", e.message)
      end
    '
    add_tag => ["time_context_added"]
  }

  # 6. CRIAÇÃO DE SUMÁRIO E LIMPEZA FINAL
  if [src_ip] and [dst_ip] {
    if [src_port] {
       mutate {
        add_field => { "event_summary" => "Conexão de %{src_ip}:%{src_port} para %{dst_ip}:%{dst_port} via %{protocol}." }
      }
    } else {
       mutate {
        add_field => { "event_summary" => "Conexão de %{src_ip} para %{dst_ip} via protocolo %{protocol}." }
      }
    }
  }

  if "_grokparsefailure" in [tags] {
    mutate {
      add_field => { "grok_error_message" => "Falha ao parsear a linha: %{message}" }
    }
  }

  mutate {
    remove_field => ["nat_info"]
  }
}

#---------------------------------------------------------------------------------
# SEÇÃO DE SAÍDA (OUTPUT)
# Envia os logs processados para o Elasticsearch.
#---------------------------------------------------------------------------------
output {
  stdout { 
    codec => rubydebug 
  }

  elasticsearch {
    hosts => ["http://elasticsearch:9200"]
    index => "mikrotik-firewall-%{+YYYY.MM.dd}"
    action => "create"
    data_stream => "false"
  }
}
